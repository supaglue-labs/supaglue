//
// Salesforce Pub/Sub API Version 1.

// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file pubsub_api.proto (package eventbus.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Supported error codes
 *
 * @generated from enum eventbus.v1.ErrorCode
 */
export enum ErrorCode {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: PUBLISH = 1;
   */
  PUBLISH = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ErrorCode)
proto3.util.setEnumType(ErrorCode, "eventbus.v1.ErrorCode", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "PUBLISH" },
]);

/**
 *
 * Supported subscription replay start values.
 * By default, the subscription will start at the tip of the stream if ReplayPreset is not specified.
 *
 * @generated from enum eventbus.v1.ReplayPreset
 */
export enum ReplayPreset {
  /**
   * Start the subscription at the tip of the stream.
   *
   * @generated from enum value: LATEST = 0;
   */
  LATEST = 0,

  /**
   * Start the subscription at the earliest point in the stream.
   *
   * @generated from enum value: EARLIEST = 1;
   */
  EARLIEST = 1,

  /**
   * Start the subscription after a custom point in the stream. This must be set with a valid replay_id in the FetchRequest.
   *
   * @generated from enum value: CUSTOM = 2;
   */
  CUSTOM = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ReplayPreset)
proto3.util.setEnumType(ReplayPreset, "eventbus.v1.ReplayPreset", [
  { no: 0, name: "LATEST" },
  { no: 1, name: "EARLIEST" },
  { no: 2, name: "CUSTOM" },
]);

/**
 *
 * Contains information about a topic and uniquely identifies it. TopicInfo is returned by the GetTopic RPC method.
 *
 * @generated from message eventbus.v1.TopicInfo
 */
export class TopicInfo extends Message<TopicInfo> {
  /**
   * Topic name
   *
   * @generated from field: string topic_name = 1;
   */
  topicName = "";

  /**
   * Tenant/org GUID
   *
   * @generated from field: string tenant_guid = 2;
   */
  tenantGuid = "";

  /**
   * Is publishing allowed?
   *
   * @generated from field: bool can_publish = 3;
   */
  canPublish = false;

  /**
   * Is subscription allowed?
   *
   * @generated from field: bool can_subscribe = 4;
   */
  canSubscribe = false;

  /**
   * ID of the current topic schema, which can be used for
   * publishing of generically serialized events.
   *
   * @generated from field: string schema_id = 5;
   */
  schemaId = "";

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 6;
   */
  rpcId = "";

  constructor(data?: PartialMessage<TopicInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.TopicInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tenant_guid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "can_publish", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "can_subscribe", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "schema_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "rpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopicInfo {
    return new TopicInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopicInfo {
    return new TopicInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopicInfo {
    return new TopicInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TopicInfo | PlainMessage<TopicInfo> | undefined, b: TopicInfo | PlainMessage<TopicInfo> | undefined): boolean {
    return proto3.util.equals(TopicInfo, a, b);
  }
}

/**
 *
 * A request message for GetTopic. Note that the tenant/org is not directly referenced
 * in the request, but is implicitly identified by the authentication headers.
 *
 * @generated from message eventbus.v1.TopicRequest
 */
export class TopicRequest extends Message<TopicRequest> {
  /**
   * The name of the topic to retrieve.
   *
   * @generated from field: string topic_name = 1;
   */
  topicName = "";

  constructor(data?: PartialMessage<TopicRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.TopicRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopicRequest {
    return new TopicRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopicRequest {
    return new TopicRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopicRequest {
    return new TopicRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TopicRequest | PlainMessage<TopicRequest> | undefined, b: TopicRequest | PlainMessage<TopicRequest> | undefined): boolean {
    return proto3.util.equals(TopicRequest, a, b);
  }
}

/**
 *
 * Reserved for future use.
 * Header that contains information for distributed tracing, filtering, routing, etc.
 * For example, X-B3-* headers assigned by a publisher are stored with the event and
 * can provide a full distributed trace of the event across its entire lifecycle.
 *
 * @generated from message eventbus.v1.EventHeader
 */
export class EventHeader extends Message<EventHeader> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<EventHeader>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.EventHeader";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventHeader {
    return new EventHeader().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventHeader {
    return new EventHeader().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventHeader {
    return new EventHeader().fromJsonString(jsonString, options);
  }

  static equals(a: EventHeader | PlainMessage<EventHeader> | undefined, b: EventHeader | PlainMessage<EventHeader> | undefined): boolean {
    return proto3.util.equals(EventHeader, a, b);
  }
}

/**
 *
 * Represents an event that an event publishing app creates.
 *
 * @generated from message eventbus.v1.ProducerEvent
 */
export class ProducerEvent extends Message<ProducerEvent> {
  /**
   * Either a user-provided ID or a system generated guid
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Schema fingerprint for this event which is hash of the schema
   *
   * @generated from field: string schema_id = 2;
   */
  schemaId = "";

  /**
   * The message data field
   *
   * @generated from field: bytes payload = 3;
   */
  payload = new Uint8Array(0);

  /**
   * Reserved for future use. Key-value pairs of headers.
   *
   * @generated from field: repeated eventbus.v1.EventHeader headers = 4;
   */
  headers: EventHeader[] = [];

  constructor(data?: PartialMessage<ProducerEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.ProducerEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "headers", kind: "message", T: EventHeader, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProducerEvent {
    return new ProducerEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProducerEvent {
    return new ProducerEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProducerEvent {
    return new ProducerEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ProducerEvent | PlainMessage<ProducerEvent> | undefined, b: ProducerEvent | PlainMessage<ProducerEvent> | undefined): boolean {
    return proto3.util.equals(ProducerEvent, a, b);
  }
}

/**
 *
 * Represents an event that is consumed in a subscriber client.
 * In addition to the fields in ProducerEvent, ConsumerEvent has the replay_id field.
 *
 * @generated from message eventbus.v1.ConsumerEvent
 */
export class ConsumerEvent extends Message<ConsumerEvent> {
  /**
   * The event with fields identical to ProducerEvent
   *
   * @generated from field: eventbus.v1.ProducerEvent event = 1;
   */
  event?: ProducerEvent;

  /**
   * The replay ID of the event.
   * A subscriber app can store the replay ID. When the app restarts, it can resume subscription
   * starting from events in the event bus after the event with that replay ID.
   *
   * @generated from field: bytes replay_id = 2;
   */
  replayId = new Uint8Array(0);

  constructor(data?: PartialMessage<ConsumerEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.ConsumerEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "event", kind: "message", T: ProducerEvent },
    { no: 2, name: "replay_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsumerEvent {
    return new ConsumerEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsumerEvent {
    return new ConsumerEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsumerEvent {
    return new ConsumerEvent().fromJsonString(jsonString, options);
  }

  static equals(a: ConsumerEvent | PlainMessage<ConsumerEvent> | undefined, b: ConsumerEvent | PlainMessage<ConsumerEvent> | undefined): boolean {
    return proto3.util.equals(ConsumerEvent, a, b);
  }
}

/**
 *
 * Event publish result that the Publish RPC method returns. The result contains replay_id or a publish error.
 *
 * @generated from message eventbus.v1.PublishResult
 */
export class PublishResult extends Message<PublishResult> {
  /**
   * Replay ID of the event
   *
   * @generated from field: bytes replay_id = 1;
   */
  replayId = new Uint8Array(0);

  /**
   * Publish error if any
   *
   * @generated from field: eventbus.v1.Error error = 2;
   */
  error?: Error;

  /**
   * Correlation key of the ProducerEvent
   *
   * @generated from field: string correlationKey = 3;
   */
  correlationKey = "";

  constructor(data?: PartialMessage<PublishResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.PublishResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "replay_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "error", kind: "message", T: Error },
    { no: 3, name: "correlationKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishResult {
    return new PublishResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishResult {
    return new PublishResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishResult {
    return new PublishResult().fromJsonString(jsonString, options);
  }

  static equals(a: PublishResult | PlainMessage<PublishResult> | undefined, b: PublishResult | PlainMessage<PublishResult> | undefined): boolean {
    return proto3.util.equals(PublishResult, a, b);
  }
}

/**
 * Contains error information for an error that an RPC method returns.
 *
 * @generated from message eventbus.v1.Error
 */
export class Error extends Message<Error> {
  /**
   * Error code
   *
   * @generated from field: eventbus.v1.ErrorCode code = 1;
   */
  code = ErrorCode.UNKNOWN;

  /**
   * Error message
   *
   * @generated from field: string msg = 2;
   */
  msg = "";

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "enum", T: proto3.getEnumType(ErrorCode) },
    { no: 2, name: "msg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

/**
 *
 * Request for the Subscribe streaming RPC method. This request is used to:
 * 1. Establish the initial subscribe stream.
 * 2. Request more events from the subscription stream.
 * Flow Control is handled by the subscriber via num_requested.
 * A client can specify a starting point for the subscription with replay_preset and replay_id combinations.
 * If no replay_preset is specified, the subscription starts at LATEST (tip of the stream).
 * replay_preset and replay_id values are only consumed as part of the first FetchRequest. If
 * a client needs to start at another point in the stream, it must start a new subscription.
 *
 * @generated from message eventbus.v1.FetchRequest
 */
export class FetchRequest extends Message<FetchRequest> {
  /**
   *
   * Identifies a topic for subscription in the very first FetchRequest of the stream. The topic cannot change
   * in subsequent FetchRequests within the same subscribe stream, but can be omitted for efficiency.
   *
   * @generated from field: string topic_name = 1;
   */
  topicName = "";

  /**
   *
   * Subscription starting point. This is consumed only as part of the first FetchRequest
   * when the subscription is set up.
   *
   * @generated from field: eventbus.v1.ReplayPreset replay_preset = 2;
   */
  replayPreset = ReplayPreset.LATEST;

  /**
   *
   * If replay_preset of CUSTOM is selected, specify the subscription point to start after.
   * This is consumed only as part of the first FetchRequest when the subscription is set up.
   *
   * @generated from field: bytes replay_id = 3;
   */
  replayId = new Uint8Array(0);

  /**
   *
   * Number of events a client is ready to accept. Each subsequent FetchRequest informs the server
   * of additional processing capacity available on the client side. There is no guarantee of equal number of
   * FetchResponse messages to be sent back. There is not necessarily a correspondence between
   * number of requested events in FetchRequest and the number of events returned in subsequent
   * FetchResponses.
   *
   * @generated from field: int32 num_requested = 4;
   */
  numRequested = 0;

  /**
   * For internal Salesforce use only.
   *
   * @generated from field: string auth_refresh = 5;
   */
  authRefresh = "";

  constructor(data?: PartialMessage<FetchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.FetchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "replay_preset", kind: "enum", T: proto3.getEnumType(ReplayPreset) },
    { no: 3, name: "replay_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "num_requested", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "auth_refresh", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchRequest {
    return new FetchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchRequest {
    return new FetchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchRequest {
    return new FetchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FetchRequest | PlainMessage<FetchRequest> | undefined, b: FetchRequest | PlainMessage<FetchRequest> | undefined): boolean {
    return proto3.util.equals(FetchRequest, a, b);
  }
}

/**
 *
 * Response for the Subscribe streaming RPC method. This returns ConsumerEvent(s).
 * If there are no events to deliver, the server sends an empty batch fetch response with the latest replay ID. The
 * empty fetch response is sent within 270 seconds. An empty fetch response provides a periodic keepalive from the
 * server and the latest replay ID.
 *
 * @generated from message eventbus.v1.FetchResponse
 */
export class FetchResponse extends Message<FetchResponse> {
  /**
   * Received events for subscription for client consumption
   *
   * @generated from field: repeated eventbus.v1.ConsumerEvent events = 1;
   */
  events: ConsumerEvent[] = [];

  /**
   * Latest replay ID of a subscription. Enables clients with an updated replay value so that they can keep track
   * of their last consumed replay. Clients will not have to start a subscription at a very old replay in the case where a resubscribe is necessary.
   *
   * @generated from field: bytes latest_replay_id = 2;
   */
  latestReplayId = new Uint8Array(0);

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 3;
   */
  rpcId = "";

  /**
   * Number of remaining events to be delivered to the client for a Subscribe RPC call.
   *
   * @generated from field: int32 pending_num_requested = 4;
   */
  pendingNumRequested = 0;

  constructor(data?: PartialMessage<FetchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.FetchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: ConsumerEvent, repeated: true },
    { no: 2, name: "latest_replay_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "rpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "pending_num_requested", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchResponse {
    return new FetchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchResponse {
    return new FetchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchResponse {
    return new FetchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FetchResponse | PlainMessage<FetchResponse> | undefined, b: FetchResponse | PlainMessage<FetchResponse> | undefined): boolean {
    return proto3.util.equals(FetchResponse, a, b);
  }
}

/**
 *
 * Request for the GetSchema RPC method. The schema request is based on the event schema ID.
 *
 * @generated from message eventbus.v1.SchemaRequest
 */
export class SchemaRequest extends Message<SchemaRequest> {
  /**
   * Schema fingerprint for this event, which is a hash of the schema.
   *
   * @generated from field: string schema_id = 1;
   */
  schemaId = "";

  constructor(data?: PartialMessage<SchemaRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.SchemaRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaRequest {
    return new SchemaRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaRequest {
    return new SchemaRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaRequest {
    return new SchemaRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SchemaRequest | PlainMessage<SchemaRequest> | undefined, b: SchemaRequest | PlainMessage<SchemaRequest> | undefined): boolean {
    return proto3.util.equals(SchemaRequest, a, b);
  }
}

/**
 *
 * Response for the GetSchema RPC method. This returns the schema ID and schema of an event.
 *
 * @generated from message eventbus.v1.SchemaInfo
 */
export class SchemaInfo extends Message<SchemaInfo> {
  /**
   * Avro schema in JSON format
   *
   * @generated from field: string schema_json = 1;
   */
  schemaJson = "";

  /**
   * Schema fingerprint
   *
   * @generated from field: string schema_id = 2;
   */
  schemaId = "";

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 3;
   */
  rpcId = "";

  constructor(data?: PartialMessage<SchemaInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.SchemaInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema_json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "rpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaInfo {
    return new SchemaInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaInfo {
    return new SchemaInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaInfo {
    return new SchemaInfo().fromJsonString(jsonString, options);
  }

  static equals(a: SchemaInfo | PlainMessage<SchemaInfo> | undefined, b: SchemaInfo | PlainMessage<SchemaInfo> | undefined): boolean {
    return proto3.util.equals(SchemaInfo, a, b);
  }
}

/**
 * Request for the Publish and PublishStream RPC method.
 *
 * @generated from message eventbus.v1.PublishRequest
 */
export class PublishRequest extends Message<PublishRequest> {
  /**
   * Topic to publish on
   *
   * @generated from field: string topic_name = 1;
   */
  topicName = "";

  /**
   * Batch of ProducerEvent(s) to send
   *
   * @generated from field: repeated eventbus.v1.ProducerEvent events = 2;
   */
  events: ProducerEvent[] = [];

  /**
   * For internal Salesforce use only.
   *
   * @generated from field: string auth_refresh = 3;
   */
  authRefresh = "";

  constructor(data?: PartialMessage<PublishRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.PublishRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "events", kind: "message", T: ProducerEvent, repeated: true },
    { no: 3, name: "auth_refresh", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishRequest {
    return new PublishRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishRequest {
    return new PublishRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishRequest {
    return new PublishRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PublishRequest | PlainMessage<PublishRequest> | undefined, b: PublishRequest | PlainMessage<PublishRequest> | undefined): boolean {
    return proto3.util.equals(PublishRequest, a, b);
  }
}

/**
 *
 * Response for the Publish and PublishStream RPC methods. This returns
 * a list of PublishResults for each event that the client attempted to
 * publish. PublishResult indicates if publish succeeded or not
 * for each event. It also returns the schema ID that was used to create
 * the ProducerEvents in the PublishRequest.
 *
 * @generated from message eventbus.v1.PublishResponse
 */
export class PublishResponse extends Message<PublishResponse> {
  /**
   * Publish results
   *
   * @generated from field: repeated eventbus.v1.PublishResult results = 1;
   */
  results: PublishResult[] = [];

  /**
   * Schema fingerprint for this event, which is a hash of the schema
   *
   * @generated from field: string schema_id = 2;
   */
  schemaId = "";

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 3;
   */
  rpcId = "";

  constructor(data?: PartialMessage<PublishResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eventbus.v1.PublishResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: PublishResult, repeated: true },
    { no: 2, name: "schema_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "rpc_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishResponse {
    return new PublishResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishResponse {
    return new PublishResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishResponse {
    return new PublishResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PublishResponse | PlainMessage<PublishResponse> | undefined, b: PublishResponse | PlainMessage<PublishResponse> | undefined): boolean {
    return proto3.util.equals(PublishResponse, a, b);
  }
}

