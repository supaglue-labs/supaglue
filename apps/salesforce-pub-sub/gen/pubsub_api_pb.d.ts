//
// Salesforce Pub/Sub API Version 1.

// @generated by protoc-gen-es v1.2.0
// @generated from file pubsub_api.proto (package eventbus.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Supported error codes
 *
 * @generated from enum eventbus.v1.ErrorCode
 */
export declare enum ErrorCode {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: PUBLISH = 1;
   */
  PUBLISH = 1,
}

/**
 *
 * Supported subscription replay start values.
 * By default, the subscription will start at the tip of the stream if ReplayPreset is not specified.
 *
 * @generated from enum eventbus.v1.ReplayPreset
 */
export declare enum ReplayPreset {
  /**
   * Start the subscription at the tip of the stream.
   *
   * @generated from enum value: LATEST = 0;
   */
  LATEST = 0,

  /**
   * Start the subscription at the earliest point in the stream.
   *
   * @generated from enum value: EARLIEST = 1;
   */
  EARLIEST = 1,

  /**
   * Start the subscription after a custom point in the stream. This must be set with a valid replay_id in the FetchRequest.
   *
   * @generated from enum value: CUSTOM = 2;
   */
  CUSTOM = 2,
}

/**
 *
 * Contains information about a topic and uniquely identifies it. TopicInfo is returned by the GetTopic RPC method.
 *
 * @generated from message eventbus.v1.TopicInfo
 */
export declare class TopicInfo extends Message<TopicInfo> {
  /**
   * Topic name
   *
   * @generated from field: string topic_name = 1;
   */
  topicName: string;

  /**
   * Tenant/org GUID
   *
   * @generated from field: string tenant_guid = 2;
   */
  tenantGuid: string;

  /**
   * Is publishing allowed?
   *
   * @generated from field: bool can_publish = 3;
   */
  canPublish: boolean;

  /**
   * Is subscription allowed?
   *
   * @generated from field: bool can_subscribe = 4;
   */
  canSubscribe: boolean;

  /**
   * ID of the current topic schema, which can be used for
   * publishing of generically serialized events.
   *
   * @generated from field: string schema_id = 5;
   */
  schemaId: string;

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 6;
   */
  rpcId: string;

  constructor(data?: PartialMessage<TopicInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.TopicInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopicInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopicInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopicInfo;

  static equals(a: TopicInfo | PlainMessage<TopicInfo> | undefined, b: TopicInfo | PlainMessage<TopicInfo> | undefined): boolean;
}

/**
 *
 * A request message for GetTopic. Note that the tenant/org is not directly referenced
 * in the request, but is implicitly identified by the authentication headers.
 *
 * @generated from message eventbus.v1.TopicRequest
 */
export declare class TopicRequest extends Message<TopicRequest> {
  /**
   * The name of the topic to retrieve.
   *
   * @generated from field: string topic_name = 1;
   */
  topicName: string;

  constructor(data?: PartialMessage<TopicRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.TopicRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopicRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopicRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopicRequest;

  static equals(a: TopicRequest | PlainMessage<TopicRequest> | undefined, b: TopicRequest | PlainMessage<TopicRequest> | undefined): boolean;
}

/**
 *
 * Reserved for future use.
 * Header that contains information for distributed tracing, filtering, routing, etc.
 * For example, X-B3-* headers assigned by a publisher are stored with the event and
 * can provide a full distributed trace of the event across its entire lifecycle.
 *
 * @generated from message eventbus.v1.EventHeader
 */
export declare class EventHeader extends Message<EventHeader> {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: bytes value = 2;
   */
  value: Uint8Array;

  constructor(data?: PartialMessage<EventHeader>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.EventHeader";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventHeader;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventHeader;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventHeader;

  static equals(a: EventHeader | PlainMessage<EventHeader> | undefined, b: EventHeader | PlainMessage<EventHeader> | undefined): boolean;
}

/**
 *
 * Represents an event that an event publishing app creates.
 *
 * @generated from message eventbus.v1.ProducerEvent
 */
export declare class ProducerEvent extends Message<ProducerEvent> {
  /**
   * Either a user-provided ID or a system generated guid
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Schema fingerprint for this event which is hash of the schema
   *
   * @generated from field: string schema_id = 2;
   */
  schemaId: string;

  /**
   * The message data field
   *
   * @generated from field: bytes payload = 3;
   */
  payload: Uint8Array;

  /**
   * Reserved for future use. Key-value pairs of headers.
   *
   * @generated from field: repeated eventbus.v1.EventHeader headers = 4;
   */
  headers: EventHeader[];

  constructor(data?: PartialMessage<ProducerEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.ProducerEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProducerEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProducerEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProducerEvent;

  static equals(a: ProducerEvent | PlainMessage<ProducerEvent> | undefined, b: ProducerEvent | PlainMessage<ProducerEvent> | undefined): boolean;
}

/**
 *
 * Represents an event that is consumed in a subscriber client.
 * In addition to the fields in ProducerEvent, ConsumerEvent has the replay_id field.
 *
 * @generated from message eventbus.v1.ConsumerEvent
 */
export declare class ConsumerEvent extends Message<ConsumerEvent> {
  /**
   * The event with fields identical to ProducerEvent
   *
   * @generated from field: eventbus.v1.ProducerEvent event = 1;
   */
  event?: ProducerEvent;

  /**
   * The replay ID of the event.
   * A subscriber app can store the replay ID. When the app restarts, it can resume subscription
   * starting from events in the event bus after the event with that replay ID.
   *
   * @generated from field: bytes replay_id = 2;
   */
  replayId: Uint8Array;

  constructor(data?: PartialMessage<ConsumerEvent>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.ConsumerEvent";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsumerEvent;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsumerEvent;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsumerEvent;

  static equals(a: ConsumerEvent | PlainMessage<ConsumerEvent> | undefined, b: ConsumerEvent | PlainMessage<ConsumerEvent> | undefined): boolean;
}

/**
 *
 * Event publish result that the Publish RPC method returns. The result contains replay_id or a publish error.
 *
 * @generated from message eventbus.v1.PublishResult
 */
export declare class PublishResult extends Message<PublishResult> {
  /**
   * Replay ID of the event
   *
   * @generated from field: bytes replay_id = 1;
   */
  replayId: Uint8Array;

  /**
   * Publish error if any
   *
   * @generated from field: eventbus.v1.Error error = 2;
   */
  error?: Error;

  /**
   * Correlation key of the ProducerEvent
   *
   * @generated from field: string correlationKey = 3;
   */
  correlationKey: string;

  constructor(data?: PartialMessage<PublishResult>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.PublishResult";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishResult;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishResult;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishResult;

  static equals(a: PublishResult | PlainMessage<PublishResult> | undefined, b: PublishResult | PlainMessage<PublishResult> | undefined): boolean;
}

/**
 * Contains error information for an error that an RPC method returns.
 *
 * @generated from message eventbus.v1.Error
 */
export declare class Error extends Message<Error> {
  /**
   * Error code
   *
   * @generated from field: eventbus.v1.ErrorCode code = 1;
   */
  code: ErrorCode;

  /**
   * Error message
   *
   * @generated from field: string msg = 2;
   */
  msg: string;

  constructor(data?: PartialMessage<Error>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.Error";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error;

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean;
}

/**
 *
 * Request for the Subscribe streaming RPC method. This request is used to:
 * 1. Establish the initial subscribe stream.
 * 2. Request more events from the subscription stream.
 * Flow Control is handled by the subscriber via num_requested.
 * A client can specify a starting point for the subscription with replay_preset and replay_id combinations.
 * If no replay_preset is specified, the subscription starts at LATEST (tip of the stream).
 * replay_preset and replay_id values are only consumed as part of the first FetchRequest. If
 * a client needs to start at another point in the stream, it must start a new subscription.
 *
 * @generated from message eventbus.v1.FetchRequest
 */
export declare class FetchRequest extends Message<FetchRequest> {
  /**
   *
   * Identifies a topic for subscription in the very first FetchRequest of the stream. The topic cannot change
   * in subsequent FetchRequests within the same subscribe stream, but can be omitted for efficiency.
   *
   * @generated from field: string topic_name = 1;
   */
  topicName: string;

  /**
   *
   * Subscription starting point. This is consumed only as part of the first FetchRequest
   * when the subscription is set up.
   *
   * @generated from field: eventbus.v1.ReplayPreset replay_preset = 2;
   */
  replayPreset: ReplayPreset;

  /**
   *
   * If replay_preset of CUSTOM is selected, specify the subscription point to start after.
   * This is consumed only as part of the first FetchRequest when the subscription is set up.
   *
   * @generated from field: bytes replay_id = 3;
   */
  replayId: Uint8Array;

  /**
   *
   * Number of events a client is ready to accept. Each subsequent FetchRequest informs the server
   * of additional processing capacity available on the client side. There is no guarantee of equal number of
   * FetchResponse messages to be sent back. There is not necessarily a correspondence between
   * number of requested events in FetchRequest and the number of events returned in subsequent
   * FetchResponses.
   *
   * @generated from field: int32 num_requested = 4;
   */
  numRequested: number;

  /**
   * For internal Salesforce use only.
   *
   * @generated from field: string auth_refresh = 5;
   */
  authRefresh: string;

  constructor(data?: PartialMessage<FetchRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.FetchRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchRequest;

  static equals(a: FetchRequest | PlainMessage<FetchRequest> | undefined, b: FetchRequest | PlainMessage<FetchRequest> | undefined): boolean;
}

/**
 *
 * Response for the Subscribe streaming RPC method. This returns ConsumerEvent(s).
 * If there are no events to deliver, the server sends an empty batch fetch response with the latest replay ID. The
 * empty fetch response is sent within 270 seconds. An empty fetch response provides a periodic keepalive from the
 * server and the latest replay ID.
 *
 * @generated from message eventbus.v1.FetchResponse
 */
export declare class FetchResponse extends Message<FetchResponse> {
  /**
   * Received events for subscription for client consumption
   *
   * @generated from field: repeated eventbus.v1.ConsumerEvent events = 1;
   */
  events: ConsumerEvent[];

  /**
   * Latest replay ID of a subscription. Enables clients with an updated replay value so that they can keep track
   * of their last consumed replay. Clients will not have to start a subscription at a very old replay in the case where a resubscribe is necessary.
   *
   * @generated from field: bytes latest_replay_id = 2;
   */
  latestReplayId: Uint8Array;

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 3;
   */
  rpcId: string;

  /**
   * Number of remaining events to be delivered to the client for a Subscribe RPC call.
   *
   * @generated from field: int32 pending_num_requested = 4;
   */
  pendingNumRequested: number;

  constructor(data?: PartialMessage<FetchResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.FetchResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FetchResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FetchResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FetchResponse;

  static equals(a: FetchResponse | PlainMessage<FetchResponse> | undefined, b: FetchResponse | PlainMessage<FetchResponse> | undefined): boolean;
}

/**
 *
 * Request for the GetSchema RPC method. The schema request is based on the event schema ID.
 *
 * @generated from message eventbus.v1.SchemaRequest
 */
export declare class SchemaRequest extends Message<SchemaRequest> {
  /**
   * Schema fingerprint for this event, which is a hash of the schema.
   *
   * @generated from field: string schema_id = 1;
   */
  schemaId: string;

  constructor(data?: PartialMessage<SchemaRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.SchemaRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaRequest;

  static equals(a: SchemaRequest | PlainMessage<SchemaRequest> | undefined, b: SchemaRequest | PlainMessage<SchemaRequest> | undefined): boolean;
}

/**
 *
 * Response for the GetSchema RPC method. This returns the schema ID and schema of an event.
 *
 * @generated from message eventbus.v1.SchemaInfo
 */
export declare class SchemaInfo extends Message<SchemaInfo> {
  /**
   * Avro schema in JSON format
   *
   * @generated from field: string schema_json = 1;
   */
  schemaJson: string;

  /**
   * Schema fingerprint
   *
   * @generated from field: string schema_id = 2;
   */
  schemaId: string;

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 3;
   */
  rpcId: string;

  constructor(data?: PartialMessage<SchemaInfo>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.SchemaInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaInfo;

  static equals(a: SchemaInfo | PlainMessage<SchemaInfo> | undefined, b: SchemaInfo | PlainMessage<SchemaInfo> | undefined): boolean;
}

/**
 * Request for the Publish and PublishStream RPC method.
 *
 * @generated from message eventbus.v1.PublishRequest
 */
export declare class PublishRequest extends Message<PublishRequest> {
  /**
   * Topic to publish on
   *
   * @generated from field: string topic_name = 1;
   */
  topicName: string;

  /**
   * Batch of ProducerEvent(s) to send
   *
   * @generated from field: repeated eventbus.v1.ProducerEvent events = 2;
   */
  events: ProducerEvent[];

  /**
   * For internal Salesforce use only.
   *
   * @generated from field: string auth_refresh = 3;
   */
  authRefresh: string;

  constructor(data?: PartialMessage<PublishRequest>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.PublishRequest";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishRequest;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishRequest;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishRequest;

  static equals(a: PublishRequest | PlainMessage<PublishRequest> | undefined, b: PublishRequest | PlainMessage<PublishRequest> | undefined): boolean;
}

/**
 *
 * Response for the Publish and PublishStream RPC methods. This returns
 * a list of PublishResults for each event that the client attempted to
 * publish. PublishResult indicates if publish succeeded or not
 * for each event. It also returns the schema ID that was used to create
 * the ProducerEvents in the PublishRequest.
 *
 * @generated from message eventbus.v1.PublishResponse
 */
export declare class PublishResponse extends Message<PublishResponse> {
  /**
   * Publish results
   *
   * @generated from field: repeated eventbus.v1.PublishResult results = 1;
   */
  results: PublishResult[];

  /**
   * Schema fingerprint for this event, which is a hash of the schema
   *
   * @generated from field: string schema_id = 2;
   */
  schemaId: string;

  /**
   * RPC ID used to trace errors.
   *
   * @generated from field: string rpc_id = 3;
   */
  rpcId: string;

  constructor(data?: PartialMessage<PublishResponse>);

  static readonly runtime: typeof proto3;
  static readonly typeName = "eventbus.v1.PublishResponse";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishResponse;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishResponse;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishResponse;

  static equals(a: PublishResponse | PlainMessage<PublishResponse> | undefined, b: PublishResponse | PlainMessage<PublishResponse> | undefined): boolean;
}

